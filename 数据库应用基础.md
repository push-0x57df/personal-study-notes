# 数据库应用基础

## 基础

### 数据库管理系统 DBMS

是一组程序的集合，用来存储数据到数据库，并可以修改和获取数据库中的数据。它的功能主要包括六个方面

1. 数据定义功能
2. 数据操纵功能
3. 数据库事务管理及运行管理
4. 数据组织、存储和管理
5. 数据库建立和维护
6. 其他功能，例如通信接口，与其他软件系统通信

### 数据库系统 DMS

由硬件、软件、人员构成，其中软件包括操作系统、数据库、数据库管理系统、应用开发工具、应用程序等，人员包括数据库管理员（OBA）、应用程序员以及用户等。

### 逻辑数据模型

数据模型是用来描述数据、组织数据和对数据进行操作的模型。**数据结构-静态特性**：描述数据库的组成对象以及对象之间的联系，**数据操作-动态特性**：指对数据对象的任何操作，主要有增删改查，**数据完整性约束**：一组完整性规则

- 层次模型

  以一个倒立的树形表示各对象之间的联系。

  特点：

  1. 每个结点只有一个双亲结点，根节点没有双亲结点
  2. 查询任意结点只有按照它的路径查看才能显示全部含义
  3. 层次数据库系统只能处理一对多的联系

  优点：

  1. 层次模型的数据结构比较简单
  2. 层次数据库的查询效率高
  3. 层次模型提供良好的完整性支持

  缺点：

  1. 现实中有很多非层次的联系
  2. 查询子女节点必须通过双亲
  3. 对插入和删除操作的限制比较多

- 网状模型

  比层次模型更具有普遍性，用图表示对象及对象之间的联系

  特点：

  1. 允许一个以上的节点无双亲
  2. 一个节点可以有多于一个的双亲

  优点：

  1. 可以更直接的描述现实世界
  2. 具有良好的性能，存取效率高

  缺点：

  1. 数据结构复杂，实现起来比较困难

- 关系模型

  用关系作为逻辑结构，实质上是二维表

  优点：

  1. 关系数据模型简单
  2. 是3种逻辑结构中唯一的具有数学理论基础的模型，它的定义及操作有严格的数学理论基础
  3. 关系模型的存取路径对用户透明，更具有独立性

## 数据库三级模式结构

### 内模式

也称存储模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式，是对数据的存储结构、存取方法、存储路径的描述，一个数据库只有一个内模式

### 模式

也称概念模式和逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户公用的数据库逻辑结构。他是数据库系统三级模式结构的中间层，既不涉及数据的物理存储细节，也不涉及应用程序的实现方式

### 外模式

也称子模式或者用户模式，它是数据库用户能看见的和使用的局部数据的逻辑结构和特征描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示

## 数据库管理系统的发展历史

### 人工管理

### 文件系统管理

### 数据库管理

## 关系型数据库

### 基本概念

#### 关系

关系模式中用于描述数据的主要结构是关系。数据对象用关系表示，数据对象之间的联系用关系表示，对数据对象的操作就是关系的运算，关系运算的结果仍是关系

#### 元组（记录）

关系是一个二维表，表中的每一行对应一个元素

#### 属性（字段）

关系二维表中每一列表示一个属性，也叫字段

#### 域

是一组具有相同数据类型的值的集合，例如性别字段的域是{'男','女'}

#### 分量

即元组中的属性值

#### 码和候选码（关键字、键）

码也叫键或关键字，它是关系中能唯一标识一个元组的属性或者属性组。码不一定由单一属性构成，也可以由多个属性组合而成

#### 主码（主键）

一个关系中可能有多个候选码，可以选择其中一个候选码作为主码

#### 主属性

包含任意码中的属性

#### 非主属性

不包含在任意候选码中的属性称之为非主属性

#### 全码

关系模式的候选码由关系表的所有属性构成，称之为全码

#### 关系模式

关系模式是型，它确定关系由哪些属性构成，即关系的逻辑结构

#### 关系数据库模式

在一个给定的现实世界领域中，所有对象及对象之间的联系的集合构成一个关系数据库

### 关系的性质

关系不仅仅是表，应该满足如下性质：

1. 列是同质的，即来自同一个域，具有相同的数据类型
2. 每列是不可再分的数据项
3. 元组不重复，即不能有完全相同的行、
4. 元组无序性，即次序无关
5. 属性无序性，即列次序无关
6. 属性不同名

## 关系模型的完整性

### 实体完整性（主键约束）

实体完整性约束条件保证关系中每个元组都是可区分的，是唯一的

**实体完整性规则**：基本关系R必须包含有码，且主属性不能取空值

空值的三种定义：

1. 还不知道具体的值
2. 值不存在
3. 值无意义

### 参照完整性（外键约束）

数据之间的存在某种联系，在关系模型中，数据之间的联系也是关系，关系之间存在某种引用

**参照完整性规则**：若属性或属性组 F 是基本关系 R 的外码，它与基本关系 S 的码 K<sub>s</sub> 相对应（基本关系R和S不一定是不同的关系），则对于 R 中每个元组在 F 上的值必须取空值（ F 的每个属性均为空值）或等于 S 中的某个元组的 K<sub>s</sub> 值

![image-20201219181658887](\数据库应用基础.assets\image-20201219181658887.png)

### 用户自定义完整性（用户自定义约束）

针对某一具体的关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的寓意要求

例如：

1. 规定某一个属性的取值范围为 0~100
2. 规定员工一周工作时间最多为 56H
3. 规定讲师的工资不能超过教授的工资
4. 规定学生的性别取值只能是“男”或“女”

用户完整性约束的定义方法：

1. 定义关系主键
2. 定义关系外键
3. 定义属性是否为空值
4. 定义属性值的唯一性
5. 定义属性值的取值范围
6. 定义属性值的默认值
7. 定义属性间函数的依赖关系

## 实体——联系模型数据建模（E-R模型）

在**实体——联系模型**中，认为现实世界是由实体、属性及实体之间的联系构成的。一般地，实体——联系模型用 E-R 图来表示

### 基本概念

#### 实体

- 概念：

  是现实世界中存在的实物，彼此之间相互区别

- 举例：

  学生、老师、汽车、工作、课程，也可以是抽象概念，比如学生选的课

#### 实体集

- 概念：

  同种类型实体的集合

- 举例：

  学生类型实体属于学生实体型，表示为：学生（学号，姓名，年龄，性别，专业）

#### 属性

- 概念：

  描述实体某方面的性质

- 举例：

  学生的学号、姓名

- 分类：

  1. 简单属性

     不可再分的最简单属性，比如姓名

  2. 复合属性

     由几部分组成，例如家庭住址，能被分成省、市、区、街道，街道还能被分为街道名、小区、门牌号

  3. 多值属性

     对应一个具体实体，它的属性值有多个，比如学生学位可能是双学位

  4. 衍生属性

     其值可以由其他值推出，例如学生年龄可以通过出生年月推导

#### 联系

- 概念：

  实体型内部的的联系和外部的联系

- 举例：

  学生和教师之间的联系、学生与选修课程之间的联系

- 分类：

  - 一对一联系
  - 一对多联系
  - 多对多联系

#### 联系的度

- 概念：

  参与联系的实体型的个数

- 举例：

  学生和班长的联系（一元联系）、学生和班级的联系（二元联系）、教师，学生和课程之间的联系（三元联系）

- 分类：

  1. 一元联系

     参与联系的实体型只有一类

  2. 二元联系

     参与联系的实体型有两类

  3. 三元联系

     参与联系的实体型有三类

  4. 多元联系

     参与联系的实体型有多个类别

#### 联系上的属性

- 举例：

  学生选课，成绩应该放在联系上，因为单独的学生和课程都不应该有成绩这个属性，这个属性是选修联系产生后产生在这个联系上的

  ![image-20201219193906692](\数据库应用基础.assets\image-20201219193906692.png)

#### 联系的参与约束

- 分类：

  1. 完全参与

     实体中每一个实体都参与了联系，用双线表示

     例如：每个员工都必须鼠疫一个部门，每个部门都必须有至少一个员工，部门和员工都是完全参与

     ![image-20201219194257066](\数据库应用基础.assets\image-20201219194257066.png)

  2. 部分参与

     实体集中只有部分参与了联系，用单线表示

     例如：员工中只有一个人（主要是部门经理）可以管理部门，每个部门都必须被管理，员工为部分参与，部门为完全参与

     ![image-20201219194632665](\数据库应用基础.assets\image-20201219194632665.png)

#### 弱实体

- 概念：

  不能单独存在的实体。弱实体必须依附其他实体才能存在

- 举例：

  家属这个实体不能单独存在，只能依附于一个员工实体

### E-R 图表示方法

![image-20201219195248775](\数据库应用基础.assets\image-20201219195248775.png)

## 扩展的实体——联系模型（EER）

### 基本概念

#### 父类（超类）/子类

![image-20201219195854982](\数据库应用基础.assets\image-20201219195854982.png)

#### 继承

子类继承父类所有的属性，并且有自己特殊的属性

#### 不相交约束

指子类实体不相交，即父类中的一个实体最多只能属于一个子类，使用字母 d 表示不相交，如果父类中的一个实体可以属于多个子类，那么子类实体就是相交的，重叠的，用字母 o 表示

![image-20201219195925037](\数据库应用基础.assets\image-20201219195925037.png)

#### 完备性约束

完备性约束指的是**完全约束**和**部分约束**

1. 完全约束

   是指父类中的实体必须属于子类中的一类，用双竖线表示

2. 部分约束

   是指可以允许父类中的实体不属于任何子类，用单竖线表示

#### 二元联系与三元联系的区别

- 二元联系

  ![image-20201219201739849](\数据库应用基础.assets\image-20201219201739849.png)

- 三元联系

  ![image-20201219201805932](\数据库应用基础.assets\image-20201219201805932.png)

  #### 聚集

  聚集是一种特殊的联系，它指的是联系之间的联系

  ![image-20201219201939380](\数据库应用基础.assets\image-20201219201939380.png)

  #### E-R 及 EER 模型的设计步骤

  1. 找出所有的实体
  2. 找出每个实体的属性
  3. 找出所有的二元联系及联系上的属性
  4. 找出多元联系上的属性
  5. 找出弱实体
  6. 找出父类与子类
  7. 找出聚集

#### E-R 及 EER 模型的设计原则

主要考虑的问题

1. 是实体还是属性
2. 是实体还是联系
3. 是二元联系还是多元联系
4. 是否使用弱实体
5. 是否使用父类和子类
6. 是否使用聚集

## 关系数据理论

### 基本概念

#### 函数依赖

设 R(U) 是一个关系模式，U 是 R 的属性集合，X、Y 是 U 的子集。对于 R(U) 的任意一个可能的关系 r，如果 r 中不存在任意两个元组，它们在 X 上的属性相同而在 Y 上的属性不同，则称“X 函数决定 Y”或“Y 函数依赖于 X”，记作 X->Y

#### 非平凡函数依赖和平凡函数依赖

关系模式 R(U) 中，U 是 R 的属性集合，X、Y 是 U 的子集，如果 Y->Y，但 Y 不包含于 X，则称 X->Y 是非平凡函数依赖，若 Y 包含于 X，则称 X->Y 是平凡函数依赖

#### 完全函数依赖和部分函数依赖

在关系模式 R(U) 中，U 是 R 的属性集合，X、Y 是 U 的子集。如果 X->Y，并且定于 X 的任意一个真子集 X<sub>1</sub>，都有 X<sub>1</sub> 不决定 Y，则称“Y完全函数依赖于 X”，若 X<sub>1</sub> 决定 Y，Y不完全函数依赖于 X，则称“Y 部分函数依赖于 X”

#### 传递函数依赖

在关系模式 R(U) 中，如果 X->Y，Y->Z，且 Y 不包含于 X，Y 不函数决定 X，Z 不包含于 Y，则称“Z传递函数依赖于 X”

#### 码

设 K 为关系模式 R(U,F) 中的属性或属性组。若 K 完全函数决定 U，则称 K 是一个候选码；若 K 部分函数决定 U，则称 K 为超码；若关系模式 R 有多个候选码，则需选定其中一个作为**主码**

### 范式

#### 第一范式

如果一个关系模式 R 的所有属性都是不可再分的基本数据项，则 R 满足第一范式

#### 第二范式

若关系模式 R 满足第一范式，并且每个非主属性都完全函数依赖于 R 的码，则称 R 满足第二范式，即不存在非主属性对码的部分依赖

#### 第三范式

若关系 R<U,F> 中不存在候选码 X、属性组 Y，以及非主属性 Z（ Z 不包含于 Y ），使得 X->Y，Y->Z 和 X 不函数决定 X 成立，则 R 满足 第三范式，若 R 属于第三范式，则 R 的每个非主属性既不部分依赖于候选码，也不传递依赖于候选码

#### BCNF

若关系模式 R<U,F> 满足第一范式，如果对于 R 的每个函数依赖 X->Y，若 Y 不包含于 X，且 X 必须有候选码，那么 R 满足 BCNF，即在 3NF 的基础上消除了主属性对码的部分依赖和传递依赖，所有的属性都不部分依赖或传递依赖于码