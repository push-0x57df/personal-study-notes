#  软件工程笔记

## 软件危机

### 概念

软件危机是指在计算机软件的开发和维护中所遇到的一系列严重问题。

### 具体表现

- 对软件开发成本和进度的估计常常很不准确。
- 用户对“已有的”软件系统不满意的现象经常发生。
- 软件产品的质量往往靠不住。
- 软件常常是不可维护的。
- 软件通常没有适当的文档资料。
- 软件成本在计算机系统总成本中的占比例逐年上升。
- 软件开发上产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。

### 产生原因

- 一方面与软件本身的特点有关，另一方面也和软件开发与维护的方法不正确有关。
- 由于软件缺乏“可见性”，在写出程序代码并在计算机上运行之前，软件开发过程进展情况较难衡量，软件的质量也难以评价。
- 软件的显著特点就是规模庞大，程序的复杂性将随着程序规模的增加而呈指数型上升。
- 轻视软件维护。
- 用户要求没有完整准确的认知就匆忙着手编写程序。

### 消除途径

- 应该对计算机软件有一个正确的认识。“软件就是程序”是错误的观念。软件是程序、数据及相关文档的完整整合。
	- 程序就是能够完成预定功能和性能的可执行的指令序列；
	- 数据是使程序能够适当地处理信息的数据结构；
	- 文档是开发、使用和维护程序所需要的的图文资料。
- 软件开发不是某种个体劳动的神秘技巧，而应该是一种组织良好、管理严密、各人员协同配合、共同完成的工程项目。

## 软件工程

## 概念

采用工程的概念、原理、技术和方法来开发与维护软件，以经济地开发软件并有效的维护它。

### 特性

1. 专注于大型软件的构造。
2. 软件工程的中心课题是控制复杂性。
3. 软件经常变化。
4. 开发软件的效率非常重要。
5. 和谐的合作是开发软件的关键。
6. 软件必须有效的支持它的用户。
7. 软件工程领域中通常是由具有一种文化背景的人替具有另一种文化背景的人创造产品。

### 基本原理

1. 用分段的生命周期计划严格管理。
2. 坚持进行阶段评审。
3. 实行严格的产品控制。
4. 采用现代的程序设计技术。
5. 结果应该能清楚的审查。
6. 开发小组人员应该少而精。
7. 承认不断改进软件工程实践的必要性。

### 软件工程方法学

1. 传统方法学
	也称为生命周期方法学或结构化范型，把软件的生命周期划分为若干个阶段，然后按顺序的完成每个阶段的任务。需要一个阶段一个阶段的按顺序完成，每个阶段都有严格的标准。
2. 面向对象方法学
	面向对象方法学具有的四个特点：
	1. 把对象（object）作为融合了数据及在数据上的操作行为的统一软件构建。
	2. 把所有的对象都划分为类（class）。每个类都定义了一组数据和一组操作，类是对具有相同数据和相同操作的一组相似对象的定义。数据用于表示对象的静态属性，是对象的状态信息。
	3. 按照父类（基类）与子类（派生类）的关系，把若干个相关类组成一个层次结构的系统（类等级）在类等级中，下层派生类自动具有上层基类中定义的数据和操作，这种现象称之为继承。

## 软件生命周期

### 定义

软件生命周期是由三个时期八个阶段组成的。

### 三个时期八个阶段

#### 软件定义

##### 问题定义

问题定义阶段必须回答的关键问题是：“要解决的问题是什么？”

通过对客户的访问调查，系统分析员扼要地写出关于问题性质、工程目标和工程规划的书面报告，经过讨论和必要的修改后这份报告应该得到客户的确认

##### 可行性研究

这个阶段要回答的关键问题是：“对上一个阶段所确定的问题有行得通的解决办法吗？”

可行性研究的结果是客户作出是否继续进行这项工程的决定的重要依据，一般来说只有投资可能取得较大效益的那些工程项目才值得继续进行下去

##### 需求分析

这个阶段的任务是准确地确定“为了解决这个问题，目标系统必须做什么”，主要确定目标系统应该具有哪些功能

一般使用数据流图、数据字典和简要的算法表示系统的逻辑模型

这一阶段的重要任务是使用需求规格说明书来准确的记录对目标系统的需求

#### 软件开发

##### 总体设计

这个阶段必须回答的问题是：“概括的说，应该怎样实现目标系统？”总体设计又称为概要设计

##### 详细设计

总体设计阶段以比较抽象概括的方式提出了解决问题的办法，详细设计阶段的任务就是把解决方法具体化，也就是回答“应该怎样具体实现这个系统呢？”

这个阶段也还不是编写程序，而是设计出程序更详细的规格说明

详细设计也被称为模块设计，在这个阶段详细的设计每个模块，确定每个模块需要的算法和数据结构

##### 编码和单元测试

这个阶段的关键任务是写出正确、容易理解、容易维护的程序模块

程序员应该选择一种程序语言来将详细设计的结果翻译成用选定语言书写的程序，并仔细测试编写出的每一个模块

##### 综合测试

这个阶段的关键任务是通过各种类型的测试以及调试，使软件达到预定的要求

最基本的测试是集成测试和验收测试

- 集成测试

  把经过单元测试的模块按照软件的设计结构按一定顺序装配起来，在装配的过程中对程序进行必要的测试

- 验收测试

  在用户的积极参与下或由用户对软件系统进行验收

#### 软件维护

##### 维护阶段

维护阶段的任务是通过各种必要的维护活动使系统持久地满足用户的需要

通常有4类维护活动：

1. 改正性维护

   诊断和改进软件在使用的过程中发现的软件错误

2. 适应性维护

   修改软件以适应环境变化

3. 完善性维护

   根据用户要求改进或扩充软件使它更加完善

4. 预防性维护

   修改软件，为将来的维护活动预先做准备

每次维护都是一次简化压缩的软件定义和开发过程，每次维护都应该准确的记录下来作为正式的文档资料加以保存

## 软件过程

软件过程是为了获得更高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤

软件过程描述了为了开发客户需要的软件，什么人，在什么时候，做什么事，以及怎样做这些事以实现某一特定的具体目标

通常使用生命周期模型简洁的描述软件过程。生命周期把生命周期划分成哪些阶段以及各个阶段的执行顺序，因此也称为**过程模型**

### 瀑布模型

传统的瀑布模型：

![image-20201221112909765](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets\image-20201221112909765.png)

实际的瀑布模型：

![image-20201221113011118](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets\image-20201221113011118.png)

特点：

1. 阶段间有顺序性和依赖性

   这个特点包含两重定义：

   1. 前一阶段的工作完成之后才能进行后一阶段的工作
   2. 前一阶段工作的输出文档就是后一阶段的输入文档，因此只有前一段的输出文档正确，后一阶段的工作才能获得正确的结果

2. 推迟实现的观点

   瀑布模型在编码之前设置了系统分析与系统设计的各个阶段，分析与设计阶段的基本任务规定在这两个阶段主要考虑目标系统的逻辑模型，不涉及软件的物理实现

   清楚地区分逻辑设计与物理设计、极可能推迟程序的物理实现，是按照瀑布模型开发软件的一条重要的指导思想

3. 质量保证的观点

   为了保证所开发的软件的质量，在瀑布模型的每个阶段都应该坚持两个重要的做法：

   1. 每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务
   2. 每个阶段结束前都应该对所要完成的文档进行评审，以便尽早发现问题，改正错误

优点：

- 可强迫开发人员使用规范的方法；
- 严格规定了每个阶段必须提交的文档
- 要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证

缺点：

- 在可运行的软件产品交付之前，用户仅能通过文档了解产品是什么样的

### 快速原型模型

快速建立起来可以在计算机上运行的程序，它所能完成的功能往往是最终产品功能的一个子集

快速原型模型的第一步是快速建立一个能反应用户主要需求的原型系统，让用户在计算机上试用它，通常用户试用原型之后会提出很多的改进意见，开发人员根据用户的意见快速的修改原型系统，然后再次请用户试用，一旦用户认为这个原型系统可以满足他们的需求，开发人员便可以根据此写软件规格说明文档，根据这份文档开发出的软件便可以满足用户需求

![image-20201221143014265](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets\image-20201221143014265.png)

优点：

快速原型模型是不带反馈环的，所以软件产品的开发基本上是线性顺序进行的，能基本上做到线性顺序开发的原因主要如下：

1. 原型系统已经通过与用户交互而得到验证，据此完成的需求规格文档正确的描述了用户的需要，因此开发后阶段基本不会因为需求规格说明文档错误导致的较大返工
2. 开发人员通过建立原型系统已经学到了很多东西，因此在设计编码过程中发生错误的可能性减小

### 增量模型

增量模型也被称为渐增模型。使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能完成特定的功能。使用第一个增量构件往往实现软件的基本需求，提供最核心的功![image-20201221145206704](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets\image-20201221145206704.png)

优点：

- 能在较短的时间里向用户提交可以完成部分工作的产品
- 逐步增加的产品功能可以使用户有较充裕的时间来学习和适应新产品从而减少一个全新的软件可能给客户组织带来的冲击

困难：

- 把每个新的增量构建集成到现有的软件体系结构中时，必须不能破坏原来已经开发的产品
- 必须把软件的体系结构设计得便于按照这种方式进行扩充，向现有的产品添加新的构件必须简单、方便

### 螺旋模型

螺旋模型的基本思想是使用原型及其他方法来尽量降低风险，理解这种模型的一个简便方法就是把它理解为在快速原型模型的每个阶段前都增加了风险分析过程

![image-20201221150731371](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets\image-20201221150731371.png)

图中带箭头的点划线长度代表当前累计的开发费用，螺旋线的角度值代表软件开发的进度。螺旋线每个周期对应于一个开发阶段。每个阶段开始时的任务是确定阶段的目标，为这些目标选择方案及设定这些方案的约束条件。接下来的任务是从风险分析的上一步工作结果，努力排除各种潜在的风险，通常用建造原型的方法来排除风险，然后启动下一个开发步骤

优点：

- 对可选方案和约束条件的强调有利于已有软件的重用，有助于把软件质量作为软件的一个重要目标
- 减少了过多的测试或测试不足所带来的风险
- 维护只是模型的另外一个周期，在维护和开发之间并没有本质的区别

缺点：

螺旋模型是风险驱动的，是它的主要优点也是缺点，需要开发人员具有丰富的风险评估经验和这方面的专门知识，否则将出现真正的风险：当项目实际上正在走向灾难时，开发人员可能还认为一切正常

### 喷泉模型

![image-20201221152702379](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets\image-20201221152702379.png)

## 可行性研究

可行性研究的目的不是解决问题，而是确定问题是否值得去解决

至少从三个方面研究可行性：

1. 技术可行性

   使用现有的技术能不能实现这个系统

2. 经济可行性

   这个系统的经济效益能超过它的开发成本吗

3. 操作可行性

   系统的操作方式在这个用户组织中能否行得通

### 步骤和方法

#### 复查系统规模和目标

分析员访问关键人员，仔细阅读和分析材料，对问题定义阶段书写的关于规模和目标的报告书进一步的复查确认

#### 研究目前正在使用的系统

研究目前正在使用的系统中的优点缺点和不足，保存优点去掉缺点补充不足

#### 导出新系统的高层逻辑模型

导出现有系统的逻辑模型，参考现有系统的逻辑模型，设想目标系统的逻辑模型，最后依据此模型建造新的物理系统

#### 进一步定义问题

把数据流图和数据字典作为讨论的基础，再一次复查问题定义、工程规模和目标

#### 导出和评价供选择的解法

分析员应该从他建议的系统逻辑出发，导出若干个较高层次的物理解法供比较和选择

#### 推荐行动方针

根据可行性研究结果决定是否继续进行这项开发工程

#### 草拟开发计划

分析员应该为所推荐的方案草拟一份开发计划

#### 书写文档提交审查

应该把上述可行性研究各个步骤的工作结果写成清晰文档，请用户、客户组织的负责人及评审组织审查

#### 工具

##### 系统流程图

###### 符号

![image-20201222082729798](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets/image-20201222082729798.png)

##### 数据流图

###### 符号

![image-20201222082948837](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets/image-20201222082948837.png)

###### 例子

![image-20201222083143300](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets/image-20201222083143300.png)

###### 命名规则

1. 为数据流（或数据存储）命名
   1. 名字应该能代表整个数据流（或数据存储）的内容而不是反应它的部分成分
   2. 不要使用空洞的、缺乏具体含义的名字
   3. 如果在为某个数据流（或数据存储）命名时遇到了困难，则可能是因为数据流图分解不当造成的
2. 为处理命名
   1. 通常先为数据流命名，再为处理命名
   2. 名字应该反映整个处理的功能，而不是它的一部分内容
   3. 名字最好由一个具体的及物动词加上一个具体的宾语组成
   4. 如果名字中仅包含一个动词，如果必须用到两个动词则应该把它拆开分别描述
   5. 如果为某个处理命名遇到了困难，则可以尝试分解

###### 用途

画数据流图的基本目的是利用它作为信息交流工具，在数据流图中只有四种基本符号，所以很容易被用户理解

##### 数据字典

###### 数据字典内容

1. 数据流
2. 数据流分量（数据元素）
3. 数据存储
4. 处理

###### 定义数据的方法

自顶向下的分解数据，直到它不需要进一步定义

由数据元素组成数据的方式只有三种基本类型

1. 顺序

   以确定次序连接两个或多个分量

2. 选择

   从两个或多个可能的元素中选择一个

3. 重复

   把指定的分量重复零次或多次

4. 可选

   某个分量是可有可无的（重复零次或一次）

###### 符号

| 符号 | 含义                                             |
| ---- | ------------------------------------------------ |
| =    | 等价于，定义为                                   |
| +    | 和，连接两个分量                                 |
| []   | 或，从方框中若干个分量选择一个，用\|隔开不同分量 |
| {}   | 重复                                             |
| ()   | 可选                                             |

常上限和下限表示花括弧，例如 1{A}5

###### 用途

数据字典最重要的用途是作为分析阶段的工具，在数据字典中建立严密一致的定义有助于改进在不同开发人员或不同小组之间的通信

#### 成本效益分析

##### 成本估记

软件开发成本主要表现为人力消耗（乘以平均工资得到开发费用）成本估计并不是精确的，往往使用不同技术校验

###### 方法

- 代码行技术

  代码行技术是比较简单的定量估算方法，它把开发每个软件功能的成本和实现这个功能需要的源代码行数连接起来，在有以往类似工程的历史数据的情况下这种方法非常有效

- 任务分解技术

  这种方法首先把软件开发工程分解为若干个相对独立的任务，再分别估计每个单独的开发任务的成本，最后累加得到软件工程的总成本

- 自动估计成本技术

  采用自动估计成本软件工具自动估算成本

## 需求分析

### 任务

#### 确定对系统的综合要求

1. 功能需求

   这方面的需求指定系统必须提供的服务

2. 性能需求

   性能需求指定系统必须满足的定时约束或容量约束，通常包扩响应速度（响应时间）、信息量速率、主存容量、磁盘容量、安全性能等方面需求

3. 可靠性和可用性需求

   定量的指定了系统的稳定性

4. 出错处理需求

   这类需求说明系统对环境错误应该怎样响应

5. 接口需求

   接口需求描述应用系统与它的环境通信格式

6. 约束

   设计约束或实现约束描述在设计或实现应用系统时应遵守的限制条件

7. 逆向需求

   逆向需求说明软件系统不应该做什么

8. 将来可能提出的要求

   应该明确地列出那些虽然不属于当前系统开发范畴，但是据分析将来很可能会提出来的要求

#### 分析系统的数据要求

必须分析系统的数据要求，通常采用建立数据模型的方法

#### 导出数据模型

综合上述两项分析结果可以导出系统的详细设计模型，通常用数据流图、实体联系图、状态转换图、数据字典和主要的处理算法描述这个逻辑模型

#### 修正系统开发计划

在分析过程中获得对系统的更深入具体的了解，可以比较准确地估计系统的成本和进度，修正以前制定的开发计划

### 状态转换图

#### 状态

- 初态 - 初始状态
- 终态 - 最终状态
- 中间状态

#### 事件

事件是在某个特定时刻发生的事情，它是对引起系统做动作或从一个系统转换到另一个状态的外界事件的抽象

#### 符号

![image-20201222105310818](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets/image-20201222105310818.png)

#### 例子

![image-20201222105325306](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets/image-20201222105325306.png)

## 形式化说明技术

按照形式化的程度可以把软件工程使用的方法分为非形式化、半形式化和形式化三类。用自然语言描述需求规格说明是典型的非形式化说明技术

形式化是描述系统特性的基于数学的技术，如果一种方法有坚实的数学基础，那么它就是形式化的

### 非形式化方法的缺点

- 矛盾

  指一组相互冲突的描述

- 二义性

  指读者可以用不同方法理解的陈述

- 含糊性

  笼统的陈述

- 不完整性

  不完整的描述

- 抽象层次混乱

  非常抽象的描述中混入了一些关于细节的低层次描述

### 形式化方法的优点

- 准确，几乎没有二义性
- 可以在不同的软件工程活动中平滑的过度
- 提供了高层确认的手段。可以使用数学方法证明设计符合规格说明，程序代码正确地实现了设计结果

### 应用形式化方法的准则

1. 应该使用适当的表示方法
2. 应该形式化，但不要过度形式化
3. 应该估算成本，进行形式化方法应用通常要事先进行大量培训
4. 应该有形式化方法顾问随时挺高咨询
5. 不应该放弃传统的软件开发方法
6. 应该建立详尽的文档
7. 不应该放弃质量标准
8. 不应该盲目的依赖于形式化方法
9. 应该测试、测试再测试
10. 应该重用，重用仍然是降低软件开发成本和提高软件开发质量的唯一合理方法

## 总体设计

由两个主要的阶段组成：系统设计阶段，确定系统的具体实现方案

### 步骤

1. 设想供选择的方案

2. 选取合理的方案

3. 推荐最佳的方案

4. 功能分解

5. 设计软件结构

6. 设计数据库

7. 制定测试计划

8. 书写文档

   包含以下几种：

   1. 系统说明

      主要包括用系统流程图描绘的系统构成方案、组成系统的物理元素清单、成本/效益分析、对最佳方案的概括描述、精华的数据流图、用层次图或结构图描述的软件结构，用IPO图描述的各个模块简单的算法、模块间的接口关系以及需求、功能和模块三者之间的交叉参照关系

9. 审查和复审

### 设计原理

#### 模块化

模块化就是把程序划分为独立命名且可以独立访问的模块，每个模块完成一个子功能，把这些模块连接起来成为一个整体，可以完成指定的功能满足用户的需求

#### 抽象

人类在认识复杂现象桂城镇使用的最强有力的思维工具。软件工程过程的每一步都是对软件解法的抽象层次进行一次精化

#### 逐步求精

为了能集中精力解决重要的问题尽量推迟对细节的考虑，求精的过程就是细化的过程

#### 信息的隐藏和局部化

应该使一个模块中的信息（过程和数据）在另一个不需要这些信息的模块中是不能访问的

#### 模块独立

模块独立的概念是模块化、抽象、信息隐藏和局部化概念的直接结果

##### 耦合

耦合是对一个软件结构内不同模块之间相互连接程度的度量。耦合强弱取决于模块间接口的复杂程度

最低程度的耦合称之为数据耦合，最高程度的耦合称之为内容耦合

尽量使用参数在两个模块中传递信息，就能做到低耦合，**尽量做到低耦合**

##### 内聚

内聚标志着一个模块内部各个元素彼此紧密结合的程度

程度最高的内聚称为功能内聚，程度最低的内聚称为偶然内聚

尽量满足一个模块实现一种功能的原则可以满足功能内聚，**尽量满足高内聚**

### 启发规则

1. 改进软件结构提高模块独立性
2. 模块规模应该适中
3. 深度、宽度、扇入、扇出都应适应
4. 模块作用域应该在控制域之内
5. 力争降低模块间接口的复杂程度
6. 设计单入口、单出口的模块
7. 模块功能应该可以预测

## 详细设计

### 人机界面设计

人机界面设计是接口设计的一个重要组成部分

#### 设计问题

1. 系统响应时间
2. 用户帮助设施
3. 出错信息处理
4. 命令交互

#### 设计指南

1. 一般交互指南
   1. 保持一致性
   2. 提供有效反馈
   3. 执行较大有破坏性动作之前提醒用户确认
   4. 允许取消绝大部分操作
   5. 减少两次操作间必须记忆的信息量
   6. 提高对话、移动和思考的效率
   7. 允许犯错误
   8. 按功能对操作分类，并据此设计屏幕布局
   9. 提供对用户工作内容敏感的帮助设施
   10. 用简单动词或者动作短语作为命名
2. 信息显示指南
   1. 只显示与当前工作内容有关的信息
   2. 不用数据淹没用户，应该用便于用户汲取的方式展示数据
   3. 使用一致的标记、标准的缩写和可预知的颜色
   4. 允许用户保持可视化的语境
   5. 产生有意义的错误信息
   6. 使用大小写、缩进和文本分组以帮助理解
   7. 使用窗口分隔不同类型的信息
   8. 使用“模拟”显示方式表达信息
   9. 高效率的使用显示屏
3. 数据输入指南
   1. 尽量减少用户的输入次数
   2. 保持信息显示和数据输入之间的一致性
   3. 允许用户自定义输入
   4. 交互应该是灵活的，用户可以选择用键盘或者鼠标
   5. 使在当前动作语境中不适用的命令不起作用，引导用户不去使用那些会引起错误的操作
   6. 让用户控制交互流，用户应该能跳过不必要的错误
   7. 对所有的输入动作都提供帮助
   8. 消除冗余输入

### 过程设计工具

#### 程序流程图

略

#### 盒图

略

#### PAD图

图标：

![image-20201223093642913](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets/image-20201223093642913.png)

例子：

![image-20201223093730751](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets/image-20201223093730751.png)

#### 判定表

![image-20201223093800079](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets/image-20201223093800079.png)

#### 判定树

![image-20201223093829648](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets/image-20201223093829648.png)

#### 过程设计语言

也称伪码，有严格的关键字的外部语法，是一种混杂的语言

## 实现

通常把软件编码和测试称之为实现

### 编码

#### 选择程序设计语言

1. 系统要求
2. 可以使用的编译程序
3. 可以得到的软件工具
4. 工程规模
5. 程序员的知识
6. 软件的可移植性要求
7. 软件的应用领域

#### 编码风格

1. 程序内部的文档

   - 恰当的标识符、适当的注解和程序的视觉组织
   - 选取含义鲜明的名字，使用缩写时应该保持规则一致
   - 正确的注解

2. 数据说明

   - 次序应该标准化，例如按照数据结构或数据类型确定说明的次序
   - 多个变量在一条语句中说明的时候按照字母顺序排列
   - 设计使用了复杂的数据结构，应该加上注解说明

3. 语句说明

   - 不为了省空间把多个语句写在同一行
   - 尽量避免复杂的条件测试
   - 尽少使用“非”条件测试
   - 应该避免大量使用循环嵌套和条件嵌套
   - 利用括号组织语句次序

4. 输入输出

   - 对所有的输入数据进行校验
   - 检查输入项的重要组合的合法性
   - 保持输入格式简单
   - 使用数据结束标记，不要求用户指定数据数目
   - 明确的数据输入交互请求
   - 当程序对数据格式要求严格时，应保持输入一致
   - 设计良好的输出报表
   - 给所有的输出数据加标志

5. 效率

   1. 程序运行时间

      - 写程序前先简化算数和逻辑的表达式
      - 仔细研究嵌套的循环，确定是否有语句从内层往外移
      - 尽量避免使用多维数组
      - 尽量避免使用指针和复杂的表
      - 使用执行时间短的算数运算
      - 不混合使用不同的数据类型
      - 尽量使用整数运算和使用布尔表达式

   2. 存储器效率

      - 考虑大型计算机的操作系统换页调度的特点
      - 在微处理机中使用最少的存储单元
      - 提高执行效率的技术通常也能提高存储器效率

   3. 输入输出的效率

      - 所有输入输出都应该有缓冲，减少通信额外开销

      - 对二级存储器（如磁盘）应选用最简单的访问方法

      - 二级存储器的输入输出应该以信息组为单位

      - 如果超高效的输入输出不容易被人们理解，应该避免采用这样的方法

### 软件测试基础

#### 目标

1. 所有测试都应该能追溯到用户需求
2. 应该在测试之前就制定好测试计划
3. 把 Pareto 原理应用到软件测试中
4. 应该从“小规模”测试开始测试并逐步扩大到“大规模”测试
5. 穷举测试是不可能的
6. 为了达到最佳测试效果，应该由独立的第三方从事测试工作

#### 测试方法

- 黑盒测试

  完全不考虑程序内部的结构和处理流程，对程序的接口进行测试，它只能测试程序能否按照规格说明书的规定正常运行，故也称为功能性测试

- 白盒测试

  与黑盒测试相反，测试者知道程序内部的结构和处理算法，按照程序内部的逻辑测试程序，检查主要执行通路能否按照要求工作

#### 测试步骤

1. 模块测试

   把模块作为单独的实体来测试，保证每个模块作为一个单一的单元能够正常工作

2. 子系统测试

   把单一的模块组在一起组成子系统来测试，主要测试模块的接口

3. 系统测试

   系统测试把子系统组装成完整的系统来测试，和子系统一起通常被称为集成测试

4. 验收测试

   把整个软件系统作为一个单一实体来进行测试，在用户的积极参与下进行，也称为确认测试

5. 平行运行

   关系重大的软件产品不会立即投入生产运行，通常和旧软件系统放在一起同时运行一段时间，不断的和旧软件系统进行比较，用户有一段时间熟悉新系统，新系统也能进行全面负荷测试

### 单元测试

#### 测试重点

1. 模块接口
2. 局部数据结构
3. 重要的执行通路
4. 出错的处理通路
5. 边界条件

### 代码审查

由审查小组正式的做人工测试源程序

#### 审查小组组成

1. 组长：没有直接参与这项工程的一个很有能力的程序员
2. 程序的设计者
3. 程序的编写者
4. 程序的测试者

#### 集成测试

1. 自顶向下集成

   需要存根程序

   能在测试早期对程序的主要控制和关键抉择进行测试

2. 自底向上集成

   不需要存根程序

#### 确认测试

- 软件配置复查

  保证软件配置的所有成分都齐全，质量符合要求，文档与程序一致

- Alpha 和 Beta 测试

  - Alpha 测试由用户在开发者的场所进行，由开发人员指导用户测试
  - Beta 测试由用户在自己的场所或者用户集中的场所测试，用户自由测试，不需要开发者指导

#### 白盒测试技术

1. 语句覆盖

2. 判定覆盖

3. 条件覆盖

4. 判定/条件 覆盖

5. 条件组合覆盖

6. 点覆盖

   流程图每个节点由一个或多个语句相对应，因此点覆盖测试标准个语句覆盖测试标准相对应

7. 边覆盖

   使测试覆盖程序流程图中每一条边得到一次测试，边覆盖测试标准和判定覆盖标准一致

8. 路径覆盖

### 黑盒测试技术

黑盒测试力图发现的错误

1. 功能不正确或者遗漏了功能
2. 界面错误
3. 数据结构错误或者外部数据访问错误
4. 性能错误
5. 初始化和终止错误

#### 方法

- 等价划分

  等价划分把程序的输入域划分为若干个数据类，据此导出测试用例

  - 如果规定了测试范围，可以划分一个有效等价类和两个无效等价类
  - 如果确定了输入数据的个数，可以划分一个有效等价类和两个无效等价类
  - 如果程序对输入值做不同处理，那么允许的输入类型是一个等价类，不允许输入的数据类型是另一个等价类
  - 如果规定了数据输入必须遵守的规则，则可以划分一个有效的等价类和若干个无效的等价类
  - 如果程序规定了输入数据为整型，则可以划分出正整数、零和负整数三个有效类
  - 如果程序的处理对象是表格，则应该使用空表，以及含一项或多项的表

- 边界值分析

  处理边界情况最容易发生错误，边界值分析法应该首先测试程序的边界值情况

- 错误推测

  根据经验推测程序中可能出现的错误，对其进行测试

## 维护

### 结构化维护和非结构化维护

- 结构化维护指的是软件配置的唯一成分是程序代码，维护活动从艰苦地评价程序代码开始
- 非结构化维护有完整的软件配置，维护活动从评价设计文档开始

### 维护的问题

1. 理解别人的代码非常困难
2. 需要维护的软件通常没有完整的文档或者没有合格的文档
3. 不能指望原有的开发人员来说明文档
4. 绝大多数软件在设计的时候没有考虑将来需要修改
5. 软件维护不是一件吸引人的工作

### 软件的可维护性

1. 可理解性

   软件可理解性表现在软件的结构、功能、接口和内部处理过程的难易度、模块化、设计文档、结构化、设计语言

2. 可测试性

   取决于程序的可理解程度，环境越复杂、程序的可执行路径越多，可测试难度就越大

3. 可修改性

   和启发规则有关。耦合、内聚、信息隐藏、局部化、控制域作用域的关系等

4. 可重用性

### 文档

文档是影响软件可维护性的决定性因素

应该满足的要求：

1. 必须描述如何使用这个系统
2. 必须描述如何安装和管理这个系统
3. 必须描述系统需求和设计
4. 必须描述系统的实现和测试

#### 用户文档

内容：

1. 功能描述，说明系统能做什么
2. 安装文档，说明怎么安装这个系统和适应特定的硬件配置
3. 使用手册，简要的说明如何使用这个系统，说明怎样使用每一个功能，以及出错时怎样恢复和重新启动
4. 参考手册，详细的说明用户能使用的系统设计以及使用方法，应该解释系统可能产生的各种错误信息的含义
5. 操作员指南，如果有操作员，应该说明操作员如何处理使用中出现的各种情况

#### 系统文档

从问题定义、需求说明到验收测试计划这一系列和系统实现相关的文档

### 软件在工程过程

#### 过程

![image-20201223113117195](%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0.assets/image-20201223113117195.png)

#### 六类活动

1. 库存目录分析

2. 文档重构

3. 逆向工程

   逆向工程是一个恢复程序设计结果的工程

4. 代码重构

   某些老程序具有比较完整、合理的体系结构，但个体模块的编码方式难于理解、测试和维护，这种情况下可以重构可疑的代码模块

5. 数据重构

6. 正向工程