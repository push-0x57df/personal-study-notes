
# 第一部分 各种算法

##  第三章 处理机调度与死锁

### 作业与作业调度

#### 先来先服务 FCFS

FCFS是最简单的调度算法，既可用于作业调度也可用于进程调度，系统按照作业到达的先后次序完成调度或者说它优先为等待时间最长的作业分配处理机资源。

FCFS已经很少单独使用，一般它会与其他算法配合

#### 短作业优先 SJF

实际情况中短作业占有很大比例，SJF下短作业会被优先执行

- 缺点
  1. 必须知道每个作业的运行时间
  2. 对长作业非常不利，长作业的周转时间会明显的增长
  3. 人机交互无法进行
  4. 未考虑算法紧迫度

#### 优先级调度算法 PSA

基于紧迫度的作业调度算法，由外部赋予作业的紧迫程度，优先相应紧迫的作业

#### 高响应比调度算法 HRRN

FCFS算法只考虑作业等待时间，SJF只考虑作业运行时间，HRRN算法是这两种算法的结合，既考虑等待时间也考虑运行时间

HRRH算法基于响应比完成进程调度
$$
响应比=\frac {等待时间 +要求服务的时间} {要求服务的时间}=\frac {响应时间} {要求服务的时间}
$$
该算法进程调度前需要进行响应比计算，需要额外开销

### 进程调度

#### 时间片轮转调度算法 

根据FCFS策略，将所有的就绪进程排成一个就绪队列，并设置一定的时间间隔产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，当该进程的时间片用完或自身运行完毕，系统将时间片分配给新的队首进程，可以保证就绪队列中的所有进程在确定的时间段内都能获得一次CPU执行

#### 优先级调度算法

在进程调度算法中引入优先级，把处理机分配给优先级最高的进程

- 分类

  - 非抢占式

    一个进程获得处理机资源，它就一直运行下去直到运行完毕或因为某种情况放弃处理机资源，系统才把处理机资源分配给新的进程

  - 抢占式

    把处理机资源非配给优先级最高的进程，但是当系统中有新的优先级更高的进程到达时，处理机资源便会被分配给优先级更高的进程

#### 多队列调度算法

将一个进程就绪队列拆分成多个，将不同类型或性质的进程放在不同的就绪队列，不同的队列可以采用不同的调度算法，不同的队列之间可以有不同的优先级

#### 多级反馈队列调度算法

调度机制：

- 设置多个就绪队列，为每个队列设置不同优先级，给优先级高的队列更小的时间片
- 每个队列都采用FCFS算法策略
- 按队列优先级调度

#### 基于公平原则的调度算法

- 保证调度算法

  给出性能保证，可以做到调度的公平性。如果系统中有n个同类型进程，为了公平应该保证每个进程获得相同处理机时间1/n

  它的实现要求系统能实现如下功能

  1. 跟踪计算每个进程自创建以来已经执行的时间
  2. 计算每个进程应该获得的处理机时间
  3. 计算进程获得处理机时间的比率，即进程实际执行的处理时间和获取的处理机响应时间之比
  4. 比较各进程获得的处理机时间比率
  5. 调度程序应该选择比率最小的进程将处理机分配给它，并让它一直运行，直到超过最接近它的进程比率为止

- 公平分享调度算法

  主要是针对用户而言的，每个用户得到的处理机时间或要求的时间比例

  例如：

  用户1的进程ABCD，用户2的进程E，则调度：

  AEBECEDEAEBECEDE... ...

  如果希望用户1获取的处理机时间是用户2的两倍：

  ABECDEABECDEABE... ...

### 实时调度

#### 最早截止时间优先 EDF

根据任务截止时间确定任务的优先级，任务的截止执行时间越早优先级越高，系统先为其分配处理机

EDF可用于抢占式调度，也可以用于非抢占式调度

#### 最低松弛度优先 LLF

根据任务的紧急（或松弛程度）进行任务调度，任务紧急度越高，赋予任务的优先级就更高，使它优先执行，例如一个任务在200ms时必须完成，它本身需要运行100ms，它在100ms时就一定要开始运行，它的松弛度就为100ms，又如另一个任务它在400ms时必须执行完它本身需要运行150ms，它的松弛度就应该为250ms，实现LLF需要系统中有一个基于松弛度的任务就绪队列，松弛度最低的任务排在前面，调度算法选择队首任务执行

该算法主要用于抢占式算法中

### 避免死锁

#### 银行家算法

每个进程进入系统时必须申明自己需要该种资源的最大单元数目，其数目不应该超过系统总量，当进程请求该组资源时，系统必须先确定是否有足够的资源分配给它，如果有，系统则计算将进程分配给这个进程之后系统是否处于安全状态，如果都能满足就分配资源给它，否则让该进程等待

## 第五章 虚拟存储器

### 页面置换算法

在进程运行过程中，若其需要访问的页面不在内存，需要把它们调入内存，但内存已经无空闲区时，为了保证进程正常运行，系统必须从内存中调出一页程序或数据送到硬盘的对换区中，但是将哪一个页面调出需要基于一定的算法

#### 最佳置换算法 Optimal

一种理论上的算法，该算法选择被淘汰的页面是以后永远不使用的或者长期不再使用的，采用此算法获得的却页率是最低的，但因为人们无法预测一个进程在内存的若干个页面哪个是未来最长时间不再访问的，所以它是无法实现的，但可以用它判断其他算法的好坏

![image-20201226231908442](%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20201226231908442.png)

#### 先进先出页面置换 FIFO

最早出现的置换算法，总是淘汰最先进入内存的页面

![image-20201226232137211](%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20201226232137211.png)

#### 最近最久未使用 LRU

将最近运行的情况作为依据的算法，将最近没有使用的页面页面调出

![image-20201226232427859](%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20201226232427859.png)

需要硬件支持：

寄存器和栈

#### 最少使用 LFU

最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小

#### Clock 置换算法

略

#### 页面缓冲算法 PBA

略

## 第六章 输入输出系统

### 早期的磁盘调度

#### 先来先服务 FCFS

根据进程请求访问磁盘的先后顺序进行调度，此算法的优点是公平简单，且对每个进程的请求都能依次得到处理，不会出现某一个进程的请求长期得不到响应的情况，但未对寻道进行优化，平均寻道时间可能比较长

![image-20201226235736098](%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20201226235736098.png)

#### 最短寻道时间优先 SSTF

选择访问磁道距离目前磁头位置最近的进程进行调度

![image-20201226235758862](%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20201226235758862.png)

### 基于扫描的磁盘调度

#### 扫描算法 SCAN

避免发生饥饿现象，除了考虑磁道与当前磁头的距离，还考虑到方向

![image-20201227001046755](%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20201227001046755.png)

#### 循环扫描算法 CSCAN

规定磁头单向移动，这样防止当磁头刚好越过某磁道，就有另一进程想访问这一磁道，磁头必须先完成由外向内再由内向外（或相反）的访问产生的巨大延迟

![image-20201227001535130](%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20201227001535130.png)

#### N步扫描算法 NStepSCAN

这种算法把磁盘请求队列分成N个子队列，磁盘将按FCFS来处理这些子队列，子队列内部采用SCAN算法避免出现磁臂粘着

当N无限大时该算法接近FCFS性能

当N趋近1时，该算法性能接近SCAN

#### 简化N步扫描算法 FSCAN

FSCAN是对NSteepSCAN算法的简化，只将磁盘请求队列分成两个子队列，一个是当前磁盘请求进程队列，另一个队列将磁盘扫描期间到达的进程放入，所有的新进程都被推迟到下一次执行


# 第二部分 概念概述

## 操作系统引论

### 操作系统的目标

1. 方便性

   操作系统的出现使得用户操作计算机更方便

2. 有效性

   各种资源能得到有效利用，使得计算机资源被高效应用

3. 可扩充性

   可以方便的添加新的功能模块和对原来的模块进行修改

4. 开放性

   能遵循世界标准规范，互相之间能进行软硬件兼容，方便实现互联

### 操作系统的作用

1. 作为用户与计算机硬件系统之间的接口

   OS处于用户和计算机硬件之间，计算机用户通过OS操作计算机硬件

2. 作为计算机系统资源的管理者

   OS可以对处理机、存储器、I/O设备以及文件进行有效的管理

3. 实现了对计算机资源的抽象

   OS中有I/O设备管理器，由它实现I/O设备的操作细节，并向上将I/O设备抽象为一组数据结构以及一组I/O操作命令

### 操作系统发展的主要动力

1. 不断提高计算机资源利用率
2. 方便用户
3. 器件不断的更新换代
4. 计算机体系结构的不断发展
5. 不断提出新的应用需求

### 操作系统发展过程

1. 未配置操作系统的计算机系统

   - 人工操作方式

     早期的计算机系统操作方式，由程序员将事先打好孔的纸带或卡片操作

     缺点：

     - 用户独占计算机系统所有资源
     - CPU等待人工操作。当用户进行装带卸带操作时，CPU和内存等资源都是空闲的

   - 脱机输入/输出方式

     事先将装有用户程序和数据的纸带装入纸带输入及，在一台外围机的控制下把纸带上的数据输入磁带上，当CPU需要这些程序和数据时，再从磁带调入内存

     数据的输入输出过程都是由外围机完成的，是在脱离主机的情况下进行的，所以被称之为脱机输入输出方式。

     主要优点：

     - 减少了CPU的空闲时间
     - 提高了I/O速度

2. 单道批处理系统

   把一批作业以脱机输入的方式输入到磁带上，在系统监督程序的管理下，这批作业一个接一个的处理。

   处理过程：

   1. 监督程序将磁带上的第一个作业装入内存，并将运行控制权交给该作业

   2. 当该作业进行完毕时，将运行控制权归还给监督程序

   3. 监督程序将第二个作业装入内存，将运行控制权交给他

      ... ...

   缺点：

   - 系统中的资源得不到充分的利用

   运行情况：

   ![image-20201227115045857](%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20201227115045857.png)

3. 多道批处理系统

   在该操作系统中，用户提交的作业首先存放在外存上并排成一个队列，称为“后备队列”。然后由作业调度程序根据一定的算法，从后备队列中选择若干作业调入内存，使他们共享计算机的各种资源。由于同时在内存中装入若干道程序，这样可以在运行程序A时利用因为I/O操作而暂停指定的CPU空档时间调度程序B运行

   优缺点：

   - 资源利用率高
   - 系统吞吐量大
   - 平均周转时间长
   - 无交互能力

   需要解决的问题：

   - 处理机争用问题
   - 内存分配和保护问题
   - I/O设备分配问题
   - 文件的组织和管理问题
   - 作业管理问题
   - 用户与操作系统的接口问题

4. 分时系统

   解决的问题：

   1. 人机交互
   2. 共享主机，多用户可共享一台主机

   分时操作系统能提供多个终端，用户可以通过终端键入命令控制主机，它能做到：

   1. 及时接收

      在系统中配置一个多路卡，多路卡的作用是能实现分时多路复用，主机能以很快的速度周期性的扫描各个终端，比如以30ms的速度扫描，对于64个终端的多路卡，不到两秒的时间可以从各个终端收集一次数据

   2. 及时处理

      作业都被装入内存，能频繁的获得处理机运行，用户可以对他的作业进行及时的控制，运行方式：

      1. 作业直接装入内存
      2. 引入时间片概念，进行时间片轮转，系统规定每个作业每次都只能运行一个时间片，时间片用完就被分配给其他进程

   分时系统特征：

   1. 多路性

      可以同时为多个用户服务

   2. 独立性

      每个用户在使用计算机时互不干扰，给人的感觉是用户自己独占计算机

   3. 及时性

      用户的命令请求能在很短的时间取得响应

   4. 交互性

      用户可以通过终端与系统进行广泛的人机对话

5. 实时操作系统

   系统的正确性不仅仅由运算结果决定，还取决于产生结果的时间

   实时系统的类型：

   1. 工业（武器）控制系统
   2. 信息查询系统
   3. 多媒体系统
   4. 嵌入式系统

   实时任务的类型：

   1. 周期性实时任务和非周期性实时任务

   2. 硬实时任务和软实时任务

      是指任务有一个严格的硬性规定的时间，超过这个时间会发生严重错误，或者软实时任务，任务有截止时间但是并不是那么的强制，偶尔超过这个时间也不会发生很严重的问题

6. 微机操作系统

   发展过程：

   1. 单用户单任务操作系统
      - CP/M
      - MS-DOS
   2. 单用户多任务操作系统
      - Windows 早期版本
   3. 多用户多任务操作系统
      - UNIX OS
      - Linux OS

### 操作系统的基本特性

- 并发

  - 并行与并发

    并行指的是同一时刻有多个事件在执行，并发指的是在同一个时间间隔上有多个事件在进行

  - 引入进程

    对内存中多个程序都分别建立一个进程，这样可以实现并发调用

- 共享

  资源复用，限定时间和地点的，是指系统资源可供内存中可并发执行的进程共同使用

  主要分为两种：

  - 互斥共享方式

    比如打印机，每次只能执行一个任务

  - 同时访问方式

    磁盘设备就是可同时访问的设备

- 虚拟

  能将一条物理信道虚拟成多条逻辑信道，使原本只能提供一对用户使用的信道可供多对用户共享使用

  实现的技术：

  - 时分复用技术：

    广泛使用的技术，能使用某一设备对某一用户服务的空闲时间转为为另一用户服务，使设备得到最充分的应用

  - 空分复用技术：

    将一个频率非常广的信道分成多个频率窄的信道供多个用户使用

- 异步

  进程是以人们不可预知的速度推进的，这一特性被称之为异步

### 操作系统的主要功能

- 处理机管理功能
  - 进程控制
  - 进程同步
  - 进程通信
  - 调度
- 存储器管理功能
  - 内存分配
  - 内存保护
  - 地址映射
  - 内存扩充
- 设备管理功能
  - 缓冲管理
  - 设备分配
  - 设备处理
- 文件管理功能
  - 文件存储空间的管理
  - 目录管理
  - 文件的读/写管理和保护
- 操作系统与用户之间的接口
  - 用户接口
  - 程序接口
- 现代操作系统的新功能
  - 系统安全
  - 网络功能和服务
  - 支持多媒体

### 操作系统设计结构

- 无结构操作系统
- 模块化结构OS
- 分层结构OS

## 进程的描述与控制

### 前趋图

使用前趋图描述进程的执行情况，前趋图是一个有向无循环图

![image-20201227162158946](%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20201227162158946.png)

### 进程的定义

为了参与并发执行的每个程序（包括数据）都能独立的运行，操作系统为止匹配了一个专门的数据结构，称之为进程控制块（PCB），系统利用PCB来描述进程的基本情况和活动过程，进而进行控制和管理进程，由程序段、相关数据段和PCB三部分构成了进程实体

对于进程的典型定义：

1. 进程是程序的一次执行
2. 进程是一个程序及其数据在处理机上顺序执行时发生的活动
3. 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位

进程的特征：

1. 动态性

   进程的实质是进程的实体的执行过程，因此动态性是它的基本特征，它由创建产生，由调度执行，由撤销消亡，具有一定的生命周期，而程序是一组有序指令的集合，被存放在某种介质上，是静态的

2. 并发性

   指多个进程实体存放于内存中，可以在同一时间段内运行，这也是操作系统的重要特征

3. 独立性

   指的是进程实体可以独立运行、独立获得资源、独立参与调度

4. 异步性

   进程能独立运行，不可预知推进的速度

### 进程的基本状态及转换

1. 进程的三种状态：

   1. 就绪

      指进程处于已经准备好运行的状态，进程已经获得了除CPU以外所有的资源

   2. 执行
      指的是进程获得CPU正在执行的状态

   3. 阻塞

      指的是进程运行中因为某些事件（I/O请求、申请缓冲区失败等）暂时无法执行。此时进程调度将其调出暂停，处理机分配给其他就绪进程

2. 三种状态的转换

   ![image-20201227164705339](%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20201227164705339.png)

3. 创建态和终止态

   1. 创建态

      进程是由创建产生的，步骤为：

      1. 申请一个空白PCB
      2. 向PCB写入控制和管理进程的信息
      3. 为该进程分配运行需要的资源
      4. 将进程设置为就绪态，加入就绪队列

      如果进程需要的资源暂时得不到满足，进程创建不能完成，此时的进程状态就是创建态

   2. 终止态

      进程会因为到达自然终止点、出现无法克服的错误或被操作系统终结或者被其他有终止权的进程终结，它就进入终止态

      步骤：

      1. 等待系统善后处理
      2. 将PCB清零并归还给系统

   ![image-20201227165438080](%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20201227165438080.png)

## 进程控制块中的数据结构

### 操作系统中用来管理控制的数据结构

在操作系统中，为每个资源和每个进程都设置了一个数据结构，用于表达其实体，我们称之为资源信息表或者进程信息表，其中包含着资源或进程的标识、描述、状态等信息以及一批指针

![image-20201227170206450](%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20201227170206450.png)

### 进程控制块的作用

1. 作为独立运行的唯一标志

   PCB已成为进程在操作系统中唯一的标志

2. 能实现间断性的运行方式

   在多道操作系统中进程的运行方式是断断续续的，在进程运行中断的时候CPU现场信息被保存到PCB供下一次运行使用，这个过程也称为保护现场

3. 提供进程管理所需要的信息

4. 实现与其他进程的同步与通信

### 进程控制块中的信息

1. 进程标识符

   - 外部标识符

     为了方便用户（进程）对进程的访问，须为每个进程设置一个外部标识符，它是由创建者提供的，通常由字母和数字组成，为了描述进程的家族关系还应该设置父进程和子进程标识，此外还可以设置用户标识

   - 内部标识

     为了方便系统对进程管理，通常为进程分配一个唯一的数字标识符，通常是进程的序号

2. 处理机状态

   也称为处理机上下文，主要由处理机各种寄存器中的内容组成的

3. 进程调度信息

   包括以下内容：

   - 进程的状态

   - 进程的优先级

   - 进程调度需要的其它信息

   - 事件

     进程由执行变成就绪态的原因

4. 进程控制信息

   - 程序的数据地址
   - 进程同步和通信机制
   - 资源清单
   - 链接指针

### 进程的组织方式

1. 线性方式
2. 链接方式
3. 索引方式

## 操作系统内核

### 支撑功能

支撑模块工作的一些功能

1. 中断处理

   中断处理是内核最基本的功能，是整个操作系统赖以活动的基础

2. 时钟管理

   时间片轮转中是由时钟管理下达的中断信息

3. 原语操作

   由若干指令完成，用于完成一定功能的一个过程

### 资源管理功能

1. 进程管理
2. 存储器管理
3. 设备管理

 ## 进程同步

进程同步的主要任务是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则或时序共享系统资源，并能很好的合作，从而使得程序的执行具有可在现性

1. 两种制约关系

   - 间接制约关系

     多个程序在执行并发时，由于共享系统资源产生的制约，如CPU、打印机等

   - 直接制约关系

     某些应用程序为了完成某任务而建立了两个或多个进程，这些进程为了完成同一项任务而相互合作，进程的关系源于他们之间的相互合作，比如都要读取相同缓冲区的数据

2. 临界资源

   打印机等诸进程采用互斥方式访问的资源

3. 临界区

   每个进程访问临界资源的那段代码称之为临界区

4. 同步机制应该遵循的准则

   1. 空闲让进

      当没有进程处于临界区时，应该让一个进程进入临界区

   2. 忙则等待

      当有程序位于临界区时，其他试图进入临界区的进程应该等待

   3. 有限等待

      对要求访问临界资源的进程应该让它在有限的时间内结束等待进入临界区

   4. 让权等待

      当进程不能进入自己的临界区时，应该释放掉处理机，免得忙等

### 信号量机制

1. 整型信号量

   整型信号量把信号量定义为一个表示资源个数的整数，它与一般的信号量不同，除了初始化以外仅能通过两个标准的原子操作wait(S)和signal(S)来访问

2. 记录型信号量

   整型信号量中，wait操作只要S<=0就会不断地扫描，会让进程进行忙等，没有遵循”让权等待“原则，记录型信号量解决了这个问题，记录型信号量采用了记录型数据结构。结构如下：

   ``` c
   typedef struct{
       int value;
       struct process_control_block *list;
   }semaphore;
   ```

   S->value的值表示系统中剩余的某类资源数目，又称之为资源信号量，每次wait操作对它减一，当S->value<0时表示该资源已经分配完毕，进程应该调用block原语让自己阻塞并插入到信号量链表S->list中去，此时S->value的绝对值是阻塞进程数量。对信号量每次signal操作会释放一个资源，S->value的值加一个，如果它还是负数表示信号量链表中仍有等待该资源的进程被阻塞，故应该调用wakeup原语将S->list中的第一个进程唤醒

### AND型信号量

在wait信号量的基础上增加一个AND条件，针对多个进程共享多个临界区资源的情况，此时wait称之为同时等待，Swait

## 进程通信

### 进程通信的类型

1. 共享存储器系统

   相互通信的进程共享一个存储区

2. 管道通信系统

   使用一个文件连接一个读进程和一个写进程，写进程通过向管道文件写入大量的字符流，读进程通过管道文件读取的方式进行进程间的通信

3. 消息传递系统

   以格式化的消息为单位，通过操作系统提供的一组通信命令（原语）进行消息传递，完成进程间的通信

4. 客户机/服务器系统

   进程通过网络环境进行通信，主要的形式：套接字、远程过程调用和远程方法调用

## 线程的基本概念

在操作系统中引入线程的概念减少程序在并发执行的时候锁付出的时空开销

### 线程的引入

1. 进程的两个基本属性

   1. 进程是一个独立的单位
   2. 进程是一个可独立调度、分派的基本单位

2. 程序并发执行需要付出的时空开销

   为了程序可并发执行，有以下步骤：

   1. 创建进程
   2. 撤销进程
   3. 进程切换

3. 线程——作为调度和分派的最基本单位

   进程作为计算机资源最小的分配单位，频繁的创建、撤销、切换操作需要较大的时空开销，为了减少这种开销，把进程作为资源的基本分派单位但不作为调度的基本单位，把调度的执行与切换交给线程，以提高效率
   
   线程是比进程更小的单位

### 线程与进程的比较

1. 调度的基本单位

   因为进程作为独立的调度和分配的基本单位所以进程可以单独运行，在每次被调度时都需要进行上下文切换，开销较大。在引入了线程的操作系统中，线程作为更小的单位可以进行单独调度运行，能剩下巨大的系统开销

2. 并发性

   在引入线程的OS中，不仅进程之间可以并发，线程之间也能并发，甚至进程中的每一个线程都可以并发，不同进程中的线程都能完成并发

3. 拥有资源

   进程可以拥有资源，线程本身并不拥有资源，仅拥有一点必不可少的、能保证它运行的资源

4. 独立性

   线程之间的独立性比进程低很多，线程的并发依赖的资源是进程中的，一个线程的资源堆栈可以被其他线程访问读写

5. 系统开销

   系统在操作进程的过程中开销大于线程

6. 支持多处理机操作系统

   在多处理机操作系统中，单线程进程只能利用一个处理机，进程只能运行在一个处理机上，但是引入线程，线程就可以运行在多个不同的处理机上

### 线程的状态和线程的控制块

1. 线程运行的三个状态

   执行态、就绪态、阻塞态，基本与进程一致

2. 线程控制块TCB

   基本与进程一致，为了控制线程，线程也有一个控制块

   通常包含的内容：

   1. 线程的标识符

   2. 一组寄存器

      包括程序计数器、状态寄存器和通用寄存器的内容

   3. 线程执行的状态

      用于描述线程处于何种运行状态

   4. 优先级

   5. 线程专有的存储区

      用于切换时存储线程的现场信息和与线程相关的统计信息

   6. 信号屏蔽

   7. 堆栈指针

      线程运行时经常会出现多重嵌套的情况

   ### 线程的实现方式

   1. 内核支持线程
   2. 用户级线程
   3. 组合方式

## 处理机的调度与死锁

### 处理机调度的层次

1. 高级调度

   高级调度又称为长程调度或者作业调度，它的调度对象是作业，主要是根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列。高级调度主要应用在多道批处理系统中，在分时和实时操作系统中不设置高级调度

2. 低级调度

   低级调度又称为进程调度或短程调度，其调度的对象是进程（或内核级进程）。主要功能是根据某种算法，决定就绪队列中哪个进程应获得处理机，并由分派程序将处理机分配给选中的进程，进程调度是最基本的一种调度，在多道批处理、分时和实时操作系统中都必须设置

3. 中级调度

   又称为内存调度。引入中级调度的目的是提高内存利用率和吞吐量。为此应该把那些暂时不能运行的进程调到外存等待，此时的进程状态称为就绪驻外存状态（或挂起状态）

### 处理机调度算法的目标

- 处理机调度算法共同的目标

  1. 资源利用率

     为了提高资源的利用率，应该使得系统中的处理机和它的资源都尽可能的保持忙碌状态
     $$
     CPU的利用率=\frac {CPU有效的工作时间} {CPU有效的工作时间+CPU空闲等待的时间}
     $$

  2. 公平性

     诸进程都能获得合理的CPU时间，不会出现进程饥饿的现象

  3. 平衡性

     调度算法应该尽可能的保持系统资源使用的平衡性

  4. 策略强制执行

     对所制定的策略其中也包含安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行

- 批处理系统的目标

  1. 平均周转时间短

     所谓周转时间是指从作业被提交到操作系统开始，到作业完成为止的这段时间间隔

  2. 系统吞吐量高

     吞吐量指的是单位时间内完成的作业数

  3. 处理机利用率高

- 分时系统的目标

  1. 响应快

     系统响应用户操作的时间快

  2. 均衡性

     指系统响应时间的快慢应与用户所请求的复杂性相适应

- 实时系统的目标

  1. 截止时间的保证

     指的是某个任务对完成时间有要求

  2. 可预测性

## 作业与作业调度

### 作业和作业步

1. 作业

   作业是比程序更广泛的一个概念，它不仅包含了通常的程序和数据，而且还包含了一份作业说明书，系统根据该说明书来对程序的运行进行控制，在批处理系统中，是以作业为基本单位从外存调入内存的

2. 作业步

   在作业运行的过程中，每个作业都经过若干个相互独立又相互关联的顺序加工步骤才能得到结果，我们把每个加工步骤称之为一个作业步

### 作业控制块 JCB

为了管理作业，在多道批处理系统中引入了作业控制块，为每个作业进行标注，其中保存了系统对作业控制的全部信息，通常有：

作业标识、用户名称、用户账号、作业类型、作业状态、调度信息、资源需求、资源使用情况等

### 作业的三阶段和三状态

阶段：

1. 收容阶段

   用户把作业提交到系统，系统为它创建JCB，并将其加入到作业后备队列中

2. 运行阶段

   从第一个状态开始到结束前，它都处于运行阶段

3. 完成阶段

   当作业运行完成、或发生异常情况而提前结束时，作业进入完成阶段，相应的作业状态称之为“完成状态”

### 作业调度的主要任务

1. 接纳多少个作业

   即允许多少个作业在进程中运行

2. 接纳哪些作业

   接纳哪些作业的依据是作业调度算法

## 进程调度

### 进程调度的主要任务

1. 保存处理机现场信息
2. 按照某种算法选取进程
3. 把处理器分配给进程

## 死锁

### 死锁的概念

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。

### 资源的分类

- 可重用资源和可消耗资源

- 可抢占资源和不可抢占资源

  不可抢占资源是指分派后无法被其他优先级更高的进程抢占的资源，比如光盘刻录机，一个进程正在刻录的时候另一个进程抢占，会引起光盘损坏

### 死锁的产生

1. 竞争不可抢占性资源引起死锁

   例如AB两个进程需要读写12两个文件，一个进程打开文件1，另一个进程打开文件2，当它们打开另一个文件的时候发现被占用，双方陷入等待导致死锁

2. 竞争可消耗资源引起死锁

3. 进程的推进顺序不当引起的死锁

### 死锁的定义

如果一组进程中的每一个进程都在等待仅由该组进程中其他进程才能引发的事件，称这组进程是死锁的

### 产生死锁的必要条件

1. 互斥条件

   在一段时间内某资源只能被一个进程占用

2. 请求和保持条件

   进程请求新的资源，未申请成功，但保持自己原有的资源不放手

3. 不可抢占条件

   进程获得的资源不能被其他进程抢占

4. 循环等待

### 处理死锁的方法

1. 预防死锁

   通过设置某些客观条件，使得产生死锁的四个必要条件不能全部成立

2. 避免死锁

   在系统资源分配的情况下使用某种策略防止系统进入不安全的状态

3. 检测死锁

   通过某些方法检测到已经发生死锁的进程，想办法把它解除出来

4. 解除死锁

   对于已发生死锁的进程，将其从死锁中解除

